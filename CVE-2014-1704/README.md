Follow-on from https://code.google.com/p/chromium/issues/detail?id=327451

In zone.cc:193 or thereabouts,

  // Guard against integer overflow.                                                                                          
  if (new_size_no_overhead < size || new_size < kSegmentOverhead) {
    V8::FatalProcessOutOfMemory("Zone");
    return NULL;
  }

The problem with this is that new_size_no_overhead and size are both signed int, and since signed overflow is undefined behavior, optimizers are free to remove this check. This kind of test is valid only with unsigned integers.

Similarly, further down, around zone:225:

  // Check for address overflow.                                                                                              
  if (position_ < result) {
    V8::FatalProcessOutOfMemory("Zone");
    return NULL;
  }

Here we are dealing with Address, which is a char*.  This check is similarly invalid with pointers.  You need to be performing this check with unsigned integers instead.

Filing as severity medium since it is unclear if the compilers are actually omitting this check.

