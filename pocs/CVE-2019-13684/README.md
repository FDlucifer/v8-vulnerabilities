<b>VULNERABILITY DETAILS</b>

For scripts over a given size threshold, Chromium persists bytecode and other
information generated by V8 to disk, allowing subsequent loads to skip the
most of the initial compilation including parsing. Chromium uses these cache
entries even when a script is loaded from a page of an origin different from
that of the one which originally caused the script to enter the cache. This
allows an attacker to reliably probe the bytecode cache and learn information
about the user's browsing history.

The attacker first selects a script on a target origin that:
* sets a global variable close to the beginning of execution (this is used to
  timestamp the "start" of the script)
* is large enough such that parsing and starting the (uncached) script takes
  a significant amount of time (the attached demonstration uses a 370 KB script
  from Yahoo)

The attack consists of two steps:

I. We identify a global variable fitting the criteria above. To this end, we use
a helper page (helper.html) -- loaded in a frame -- to record the initial set of
properties present in the script global (`window`). Then, we load the target
script by injecting a `script` element with a `load` callback. The callback is
used to identify the first new property set on the global object (by comparing
the global keys against the list of keys pre-injection). Our example performs
this step in the user's browser, as part of the attack process; but it could
also be performed by the attacker beforehand.

II. We conduct two measurements to detect whether or not the script's bytecode
was previously cached.

Measurement 1: Using the property name from above we define a setter with that
name on the global. Then, we load the target script by injecting a `script`
element with a `load` callback. The target script is loaded and runs as
usual. However, when it sets that global variable, this triggers our setter,
which records a timestamp (tSet).

When the target script finishes running, our `load` callback is executed. In
this callback, we use the Resource Timing API to retrieve the timestamp at which
the download of the target script's source completed (tDownload).

The time it took to parse and "boot" up the target script (independent of
network variability) is: tBoot1 = tDownload - tSet. If the script was not
cached then tBoot1 will be relatively large (e.g., 80ms); at this point, V8 will
produce a serialized dump of compilation information and bytecode which Chromium
will cache. Otherwise, tBoot1 will be relatively small (e.g., 13ms).

Measurement 2: Repeat the measurement process to compute tBoot2. Compare tBoot1
and tBoot2. In the case of a hit, the two will be similarly small. In the case
of a miss, the second measurement will be 2.5x-10x smaller than the first
(e.g., 13ms vs 80ms), as the script load for tBoot2 will have used the entry
created in the on-disk bytecode cache after the collection of tBoot1.

The entire process takes around 100ms total to check a hit or miss for a target
script URL, and can be performed multiple times and in parallel to bulk-query
the cache for a list of targets (e.g. to scan the Alexa Top Sites).

Our attack was originally developed for Chromium 65. The Chromium 66 release
changed the behavior of the cache system such that the in-memory compilation
cache kicked in before the on-disk bytecode cache, masking the performance
difference in the case of a miss. We took advantage of the flaw mentioned at
[https://cs.chromium.org/chromium/src/v8/src/compilation-cache.cc?l=122-125&rcl=bf02b7365459977012be61c8fd5c9df31f360fd0]
to disable the in-memory compilation cache for the target script before the
attack runs. We insert a load of the target script URL with an additional '?'
appended, which resolves to the same content but is considered a unique URL by
Chromium. As described in the comment, this breaks the in-memory cache for
future loads of scripts with that content, allowing us to carry the attack for
the target script and the on-disk cache as before.

<b>VERSION</b> (tested on 3 systems)

Chrome Version: 66.0.3359.117 stable
Operating System: Windows 10 Pro Version 1709 (OS Build 16299.371)

Chrome Version: 65.0.3325.181 stable
Operating System: macOS 10.10.5

Chrome Version: 66.0.3359.117 stable
                (`chromium 66.0.3359.117-1` package from the Arch repository)
Operating System: Arch Linux

<b>REPRODUCTION CASE</b>

Attached are files that demonstrate querying Chromium's bytecode cache to
determine whether the user has visited Yahoo and executed some of its JS. To run
the attack:

1) Place `attack.html` and `helper.html` in the same directory.
2) Navigate to `yahoo.com` and allow the page to load fully
3) Close Yahoo and open `attack.html`, which will report a HIT for Yahoo's JS
   in Chromium's bytecode cache (indicating that you visited Yahoo)
4) Close `attack.html` and clear all browsing data
5) Re-open `attack.html`, which will now report a MISS for Yahoo's JS in the
   bytecode cache