the function PerfJitLogger::LogWriteDebugInfo https://cs.chromium.org/chromium/src/v8/src/diagnostics/perf-jit.cc?rcl=53366c4eab3aa7def56310d7cbafc23c33179bc6&l=331 uses the same raw point code between Garbage Collect, witch may cause UAF(use after GC move the object) 

void PerfJitLogger::LogWriteDebugInfo(Code code, SharedFunctionInfo shared) {   ---------------------->1 code is a raw pointer without handlify
  // Compute the entry count and get the name of the script.
  uint32_t entry_count = 0;
  for (SourcePositionTableIterator iterator(code.SourcePositionTable());
       !iterator.done(); iterator.Advance()) {
    entry_count++;
  }
  if (entry_count == 0) return;
  // The WasmToJS wrapper stubs have source position entries.
  if (!shared.HasSourceCode()) return;
  Isolate* isolate = shared.GetIsolate();
  Handle<Script> script(Script::cast(shared.script()), isolate);

  PerfJitCodeDebugInfo debug_info;

  debug_info.event_ = PerfJitCodeLoad::kDebugInfo;
  debug_info.time_stamp_ = GetTimestamp();
  debug_info.address_ = code.InstructionStart();
  debug_info.entry_count_ = entry_count;

  uint32_t size = sizeof(debug_info);
  // Add the sizes of fixed parts of entries.
  size += entry_count * sizeof(PerfJitDebugEntry);
  // Add the size of the name after each entry.

  Handle<Code> code_handle(code, isolate);
  Handle<SharedFunctionInfo> function_handle(shared, isolate);
  for (SourcePositionTableIterator iterator(code.SourcePositionTable());
       !iterator.done(); iterator.Advance()) {
    SourcePositionInfo info(GetSourcePositionInfo(code_handle, function_handle,   ---------------------->2 GetSourcePositionInfo may cause a GC through path "GetSourcePositionInfo->InliningStack->SourcePositionInfo->GetPositionInfo->InitLineEnds->CalculateLineEnds->NewFixedArray"
                                                  iterator.source_position()));
    size += GetScriptNameLength(info) + 1;
  }

  int padding = ((size + 7) & (~7)) - size;
  debug_info.size_ = size + padding;
  LogWriteBytes(reinterpret_cast<const char*>(&debug_info), sizeof(debug_info));

  Address code_start = code.InstructionStart();        --------------------------->3 raw pointer is used after heap allocation

  for (SourcePositionTableIterator iterator(code.SourcePositionTable());
       !iterator.done(); iterator.Advance()) {
    SourcePositionInfo info(GetSourcePositionInfo(code_handle, function_handle,   
                                                  iterator.source_position()));
    PerfJitDebugEntry entry;
    // The entry point of the function will be placed straight after the ELF
    // header when processed by "perf inject". Adjust the position addresses
    // accordingly.
    entry.address_ = code_start + iterator.code_offset() + kElfHeaderSize;
    entry.line_number_ = info.line + 1;
    entry.column_ = info.column + 1;
    LogWriteBytes(reinterpret_cast<const char*>(&entry), sizeof(entry));
    // The extracted name may point into heap-objects, thus disallow GC.
    DisallowHeapAllocation no_gc;
    std::unique_ptr<char[]> name_storage;
    Vector<const char> name_string = GetScriptName(info, &name_storage, no_gc);
    LogWriteBytes(name_string.begin(),
                  static_cast<uint32_t>(name_string.size()) + 1);
  }
  char padding_bytes[8] = {0};
  LogWriteBytes(padding_bytes, padding);
}

Acturaly, this issue is similar to https://bugs.chromium.org/p/chromium/issues/detail?id=1033407