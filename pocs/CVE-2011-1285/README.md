Upstream http://code.google.com/p/v8/issues/detail?id=1108

Lasse:
The RegExpExecStub is used to call generated RegExp code from JS code.
RegExp code is generally treated as C-code in its calling convention (it has no JS stack-frames, and can call directly to C functions in some cases, like stack overflow). 
Normally when we call C code from JS code, we use a specific C entry protocol that sets up the stack and (global) C variables correctly. However, the RegExpExecStub didn't do this, and just called the RegExp code.
That means that some C-level variables were not set up correctly, and if the RegExp code called out to C code, it would be in an incorrect state.
The state that wasn't set correctly was Top::c_entry_fp_address and Top::context_address.
The c_entry_fp_address is a link to the last JS frame on the JS stack. It's used to traverse the JS stack by C code.
The context_address points to the current JS context. It's probably not changing much in the same thread.

When returning (properly) from C code, we always clear the k_c_entry_fp_address, but only clear the context address in debug mode (MacroAssembler::LeaveExitFrameEpilogue).
If we reenter JS from C code, we don't clear either (JSEntryStub::GenerateBody).

If I'm not missing anything, it means that a calling sequence of C -> JS -> C -> JS -> RegExp -> C could leave the c_entry_fp_address as the one set by the first JS->C call, which means that stack traversal during the final C call will skip the second JS call's stack frames. Maybe that can cause some JS-heap objects to be GC'ed during the C call, because the stack frames aren't traversed for GC roots, leaving the pointers of that stack potentially dangling.
The unhandled pointers on the stack will still point to V8 Heap memory - potentially to the old-semispace of new-space, or into the middle of other objects in a compacted old-space. If an attacked finds a way to predict GCs with uncanny precission, and makes such a pointer suddently point into the middle of a specially crafted string, he might be able to use that to read arbitrary memory, because the middle of a string can look like the header of a very long flat string object where you can read individual 16-bit values using String.prototype.charCodeAt. it may even be possible to write arbitrary memory, if you can make the data look like a long JS Array.

I think it'll be incredibly hard to pull off, but I can't say that it's impossible (that's why we need real security people, not just paranoid engineers!)