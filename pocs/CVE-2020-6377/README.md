UserAgent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36

Steps to reproduce the problem:
Repro Steps:
1 Build chromium with ASAN(Chromium 80.0.3979.0 ).
2 Start webserver.
	python3.6m -m http.server 8605
3 ./chrome --js-flags="--expose-gc" http://127.0.0.1:8605
4 Click "play" button,and repro use-after-free.

What is the expected behavior?

What went wrong?
The cause of this bug is that the memory pointed to by the AudioBus pointers stored in the local variables "input_buses" and "output_buses" in the AudioWorkletHandler :: Process function is incorrectly gc, causing UAF.
The local variable,input_buses and output_buses are shown below.

void AudioWorkletHandler::Process(uint32_t frames_to_process) {
.....
  if (processor_ && !processor_->hasErrorOccured()) {
    Vector<AudioBus*> input_buses;
    Vector<AudioBus*> output_buses;
    for (unsigned i = 0; i < NumberOfInputs(); ++i) {
      // If the input is not connected, inform the processor of that
      // fact by setting the bus to null.
      AudioBus* bus = Input(i).IsConnected() ? Input(i).Bus() : nullptr;
      input_buses.push_back(bus);
    }
    for (unsigned i = 0; i < NumberOfOutputs(); ++i)
      output_buses.push_back(Output(i).Bus());
............
    // Run the render code and check the state of processor. Finish the
    // processor if needed.
    if (!processor_->Process(&input_buses, &output_buses, &param_value_map_) ||
        processor_->hasErrorOccured()) {
      FinishProcessorOnRenderThread();
    }
  }......
  }
}

During the execution of processor _-> Process, if the AudioWorkletNode object is released, it will cause the AudioWorkletHandler object to be released, thereby releasing the inputs_ member and outputs_ member in the AudioNode object, while the input_buses and output_buses in the above code snippet are still retained Pointer to AudioBus.

Vector<std::unique_ptr<AudioNodeInput>> inputs_;
Vector<std::unique_ptr<AudioNodeOutput>> outputs_;

PoC process:

1. Create an AudioContext object and AudioWorkletNode object, and set the numberOfInputs property of the AudioWorkletNode object to a larger value.
2. After adding AudioWorkletNode to DestinationNode, the above-mentioned AudioWorkletHandler :: Process is called.
3. Call location.reload () at the appropriate time to refresh the page, and then call gc () to force garbage collection.
4.During the garbage collection process, for the AudioContext object in the page, because the IsContextDestroyed () method returns true, the AudioWorkletNode object in the page cannot be tracked, so it will be GCed. In the end, the inputs_ and outputs_ members of the AudioNode will be Released, but local variables input_buses and output_buses in AudioWorkletHandler :: Process are still in use.

void ActiveScriptWrappableBase::TraceActiveScriptWrappables(
    v8::Isolate* isolate,
    Visitor* visitor) {
......
......
  for (const auto& active_wrappable : *active_script_wrappables) {
    HeapObjectHeader const* const header =
        active_wrappable->GetHeapObjectHeader();
    if ((header == BlinkGC::kNotFullyConstructedObject) ||
        header->IsInConstruction())
      continue;

    if (active_wrappable->IsContextDestroyed())
      continue;

    if (!active_wrappable->DispatchHasPendingActivity())
      continue;

    ScriptWrappable* script_wrappable = active_wrappable->ToScriptWrappable();
    visitor->Trace(script_wrappable);
  }
}

Did this work before? N/A 

Chrome version: 80.0.3979.0  Channel: stable
OS Version: 6.1 (Windows 7, Windows Server 2008 R2)
Flash Version: 

The cause of this bug is that the memory pointed to by the AudioBus pointers stored in the local variables "input_buses" and "output_buses" in the AudioWorkletHandler :: Process function is incorrectly gc, causing UAF.
The local variable,input_buses and output_buses are shown below.

void AudioWorkletHandler::Process(uint32_t frames_to_process) {
.....
  if (processor_ && !processor_->hasErrorOccured()) {
    Vector<AudioBus*> input_buses;
    Vector<AudioBus*> output_buses;
    for (unsigned i = 0; i < NumberOfInputs(); ++i) {
      // If the input is not connected, inform the processor of that
      // fact by setting the bus to null.
      AudioBus* bus = Input(i).IsConnected() ? Input(i).Bus() : nullptr;
      input_buses.push_back(bus);
    }
    for (unsigned i = 0; i < NumberOfOutputs(); ++i)
      output_buses.push_back(Output(i).Bus());
............
    // Run the render code and check the state of processor. Finish the
    // processor if needed.
    if (!processor_->Process(&input_buses, &output_buses, &param_value_map_) ||
        processor_->hasErrorOccured()) {
      FinishProcessorOnRenderThread();
    }
  }......
  }
}

During the execution of processor _-> Process, if the AudioWorkletNode object is released, it will cause the AudioWorkletHandler object to be released, thereby releasing the inputs_ member and outputs_ member in the AudioNode object, while the input_buses and output_buses in the above code snippet are still retained Pointer to AudioBus.

Vector<std::unique_ptr<AudioNodeInput>> inputs_;
Vector<std::unique_ptr<AudioNodeOutput>> outputs_;

PoC process:

1. Create an AudioContext object and AudioWorkletNode object, and set the numberOfInputs property of the AudioWorkletNode object to a larger value.
2. After adding AudioWorkletNode to DestinationNode, the above-mentioned AudioWorkletHandler :: Process is called.
3. Call location.reload () at the appropriate time to refresh the page, and then call gc () to force garbage collection.
4.During the garbage collection process, for the AudioContext object in the page, because the IsContextDestroyed () method returns true, the AudioWorkletNode object in the page cannot be tracked, so it will be GCed. In the end, the inputs_ and outputs_ members of the AudioNode will be Released, but local variables input_buses and output_buses in AudioWorkletHandler :: Process are still in use.

void ActiveScriptWrappableBase::TraceActiveScriptWrappables(
    v8::Isolate* isolate,
    Visitor* visitor) {
......
......
  for (const auto& active_wrappable : *active_script_wrappables) {
    HeapObjectHeader const* const header =
        active_wrappable->GetHeapObjectHeader();
    if ((header == BlinkGC::kNotFullyConstructedObject) ||
        header->IsInConstruction())
      continue;

    if (active_wrappable->IsContextDestroyed())
      continue;

    if (!active_wrappable->DispatchHasPendingActivity())
      continue;

    ScriptWrappable* script_wrappable = active_wrappable->ToScriptWrappable();
    visitor->Trace(script_wrappable);
  }
}