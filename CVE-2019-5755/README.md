== VULNERABILITY DETAILS ==

The typer sets the type of SpeculativeSafeIntegerSubtract to an
intersection with kSafeInteger. This is missing the -0 case. In
particular, ((-0) - 0) should return (-0), but due to the
intersection, the typer ignores this return value. This can be used to
perform buggy range calculations, which can be used to perform a
"standard" exploit (explained below) using CheckBounds elimination to
obtain an OOB RW primitive.

Suggested Security Severity: High (at least as per my understanding of
the severity guidelines at [SevGuid]).

== VERSION ==

This bug has been in v8 since Nov 2017 or earlier (see [specAddfix]),
and can be triggered on practically all recent versions of v8 (i.e.,
any release in the past year or so).

== REPRODUCTION CASE ==

Run via `d8 --allow-natives-syntax`:

```
function foo(trigger) {
  return Object.is((trigger ? -0 : 0) - 0, -0);
}

console.log(foo(false));
%OptimizeFunctionOnNextCall(foo);
console.log(foo(true)); // expected: true, got: false
```

To test on Chrome instead:

```
function foo(trigger) {
  return Object.is((trigger ? -0 : 0) - 0, -0);
}

console.log(foo(false));
for(var i=10000000;i>0;--i){foo(false);}
console.log(foo(true)); // expected: true, got: false
```

== EXPLOITATION ==

As demonstrated by the bug discovered by Project Zero at [p0bug],
incorrect handling of minus-zero within the typer can be used (via the
simplified lowering phase, after moving past the typer and load
elimination phases which also perform typing), to create a SameValue
node (via Object.is) which will propagate the feedback type which will
then be used for (buggy) range calculations. We can then use this
result for the standard exploit using CheckBounds elimination to
obtain an OOB RW primitive, via a JS array.

== PROPOSED FIX ==

The fix for this is a one-line change:

```
--- a/src/compiler/operation-typer.cc
+++ b/src/compiler/operation-typer.cc
@@ -684,3 +684,3 @@ Type OperationTyper::SpeculativeSafeIntegerSubtract(Type lhs, Type rhs) {
   // SimplifiedLowering::VisitSpeculativeAdditiveOp.
-  return result = Type::Intersect(result, cache_.kSafeInteger, zone());
+  return result = Type::Intersect(result, cache_.kSafeIntegerOrMinusZero, zone());
 }
```

PS: I believe the `result =` is not necessary and can be removed (but
I didn't include it in the diff, since it is irrelevant to the
discussion).

== HOW BUG WAS FOUND + HISTORICAL ANALYSIS ==

The bug described above was found during a source-review, when I
noticed that there was a discrepancy between the preceding function
(for addition) and this. Upon looking at the git history, I noticed a
relevant fix made in the preceding function
(i.e. `OperationTyper::SpeculativeSafeIntegerAdd`) on Nov 16, 2017
(see [specAddFix]). The commit message indicated that the aim was to
have also fixed `SpeculativeSafeIntegerSubtract`, but this seems to
have been missed somehow, and this bug has been lying dormant for at
least a year.

== CREDIT INFORMATION ==

Reporter Credit: Jay Bosamiya

== LINKS ==

+ [SevGuid] https://chromium.googlesource.com/chromium/src/+/master/docs/security/severity-guidelines.md
+ [p0bug] https://bugs.chromium.org/p/project-zero/issues/detail?id=1710
+ [specAddFix] https://chromium.googlesource.com/v8/v8/+/82271defd67347c146a3f71d3aad313f00658b48
