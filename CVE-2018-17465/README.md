<b>VULNERABILITY DETAILS</b>
While in the following specified conditions, the compactor will operate on a undefined slot:
1. Incremental marking is in the compacting stage.
2. the victim object is a fast object, usually created by object literal or "new Object()" expression.
3. the old-to-old remember set of the page containing the victim records a slot inside the victim. When crashes, this slot may reset an object in the new space.
4. The victim object then MigrateFastToSlow, shrinking itself to 3 * kPointerSize bytes.But the filler object to fill that space left out is created without cleaning the content of its space.
5. The space left out at 4 is not allocated out.

Because 4  does not clean the content, when the compactor tries to update pointers, it will access the undefined content.

<b>VERSION</b>
V8 Version: 6.3.298.0
Operating System: Various Android version.

<b>REPRODUCTION CASE</b>
I can't reproduce it simply.

<b>FOR CRASHES, PLEASE INCLUDE THE FOLLOWING ADDITIONAL INFORMATION</b>
Type of crash: v8
Crash State: see the attached crash log.

The log file UpdateUntypedPointer.txt records the whole procedure I debug using gdb.

The $13 is the page contains the problematic slot. And the page's invalidated_slots_ set contains the invalidated_object which has been shrinked when MigrateFastToSlow. The victim (invalidated) object original has size 136, but now 12.

To address my point more clear, the patch that confirmed fixing is also attached.
